## Appendix E: Program Listing.

### Embedded.

#### main.h

```c++
#ifndef MAIN_H
#define MAIN_H

#include "mbed.h"
#include "adc.h"
#include "communications.h"

int main();

#endif
```
#### main.cpp

```c++
#include "main.h"

int main()
{
    usb_serial.baud(1500000);

    // attach the serial interrupt. These signals are handled in
    // communications.cpp by the control signals function.
    usb_serial.attach(&control_signals);
    while(1)
    {

        if(data_ready == 1)
        {
            // Send the data array.
            data_tx();
            // Reset the flag
            data_ready = 0;
        }
    }
    printf("ERROR: main loop ended somehow.\n");
}
```

+++++

#### communications.h

```c++
#ifndef COMMUNICATIONS_H
#define COMMUNICATIONS_H

#include <stdint.h>
#include <string.h>
#include "mbed.h"

#include "adc.h"
#include "pins.h"

extern Serial usb_serial;

void control_signals();

void data_tx();

#endif
```
#### communications.cpp

```c++
#include "communications.h"

Serial usb_serial(USBTX, USBRX);

volatile int number_of_samples_to_TX = 0;

void control_signals()
{
    switch (usb_serial.getc())
    {
        case 'P':
        case 'p':
        {
            // prepare the adc.
            adc.setup();
            break;
        }
        case 'R':
        case 'r':
        {
            // Check status register
            // printf("%d samples, %dx decimation\n", NUMBER_OF_SAMPLES, 1<<DECIMATION_RATE);
            adc.read_status_register(true);
            break;
        }
        case 'S':
        case 's':
        {
            adc.start_sampling();
            break;
        }
        case 'T':
        case 't':
        {
            adc.stop_sampling();
            break;
        }
        case 'D':
        case 'd':
        {
            // Change decimation rate
            switch (usb_serial.getc())
            {
                case '0': {adc.change_decimation_rate(0); break;}
                case '1': {adc.change_decimation_rate(1); break;}
                case '2': {adc.change_decimation_rate(2); break;}
                case '3': {adc.change_decimation_rate(3); break;}
                case '4': {adc.change_decimation_rate(4); break;}
                case '5': //fall through to default
                default : {adc.change_decimation_rate(5);}
            }
            break;
        }
        case 'L':
        case 'l':
        {

            switch (usb_serial.getc())
            {
                case '3': {number_of_samples_to_TX = 16384; break;}
                case '2': {number_of_samples_to_TX = 8192; break;}
                case '1': {number_of_samples_to_TX = 4096; break;}
                case '0': // fall through to default
                default: {number_of_samples_to_TX = 1024; break;}
            }
            break;
        }

        case 'F':
        case 'f':
        {
            adc.power_up();
            adc.write_control_register(0x0003, 0x23F0);
            adc.power_down();
            adc.read_offset_register(true);
            break;
        }
        case 'G':
        case 'g':
        {
            // adc.power_up();
            // adc.write_control_register(0x0004, 0x5FFF);
            // adc.power_down();
            adc.read_gain_register(true);
            break;
        }
        case 'V':
        case 'v':
        {
            // adc.power_up();
            // adc.write_control_register(0x0005, 0x0000);
            // adc.power_down();
            adc.read_overrange_register(true);
            break;
        }
        default:
        {}
    }
}

void data_tx()
{

    printf("start\n");

    for(int tx_index = 0; tx_index < number_of_samples_to_TX; tx_index++)
    {
        printf("%08lx\n", sample_array[tx_index]);
    }
    printf("stop\n");

}
```

+++++

#### adc.h

```c++
#ifndef ADC_H
#define ADC_H

#include <stdint.h>
#include "mbed.h"
#include "pins.h"
#include "communications.h"

#define MCLK_FREQ 40000000

#define HIGH 1
#define LOW 0


#define DEFAULT_DECIMATION_RATE 0x5
// Decimation rate table:
// | Binary | Rate |   BW   | Output Data Rate |
// |--------|------|--------|------------------|
// | 0b000  |  1x  |   1M   |       2.5 MSPS   |
// | 0b001  |  2x  |  500k  |      1.25 MSPS   |
// | 0b010  |  4x  |  250k  |       625 kSPS   |
// | 0b011  |  8x  |  125k  |     312.5 kSPS   |
// | 0b100  | 16x  | 62.5k  |    156.25 kSPS   |
// | 0b101  | 32x  | 31.25k |    78.125 kSPS   |

// 16384 is the maximum power of two that can fit in memory. We are always sampling the highest number of samples, but
// only transmit a subset because the transmission takes much much longer than the sampling.
#define NUMBER_OF_SAMPLES 16384


class ADC_Class
{
public:
    ADC_Class();
    void static setup();
    void static power_up();
    void static power_down();
    void static start_sampling();
    void static stop_sampling();
    void static change_decimation_rate(int multiplier);
    uint16_t static read_status_register(bool print_to_console);
    uint16_t static read_offset_register(bool print_to_console);
    uint16_t static read_gain_register(bool print_to_console);
    uint16_t static read_overrange_register(bool print_to_console);
    void static collect_samples();

// private:
    uint16_t static control_reg_1_state;
    uint16_t static control_reg_2_state;

    uint16_t static read_adc_reg(uint8_t offset);
    uint32_t static read_data_word();
    void static write_control_register(uint16_t control_register, uint16_t value);
    void static wait_4_MCLK_cycles();

};

extern ADC_Class adc;
extern volatile int data_ready;
extern volatile uint32_t sample_array[];
#endif
```
#### adc.cpp

```c++
#include "adc.h"

uint16_t ADC_Class::control_reg_1_state = 0x0000;
uint16_t ADC_Class::control_reg_2_state = 0x0000;

ADC_Class adc;

volatile uint32_t busy_wait_variable;
volatile uint32_t sample_array[NUMBER_OF_SAMPLES];
volatile int data_ready = 0;

ADC_Class::ADC_Class()
{
    dataBus.input();
    notSync = HIGH;
    notReset = HIGH;
    notChipSelect = HIGH;
    notRead = HIGH;

    // reset to start in a defined state.
    notReset = LOW;
    wait_4_MCLK_cycles();
    notReset = HIGH;
    wait_4_MCLK_cycles();
    power_down();
}

void ADC_Class::setup()
{

    // configure pins for write operations.
    // dataBus is bi directional.
    dataBus.output();

    // Control Register 2
    // // BIT | NAME  | DESCRIPTION
    // // ----|------ |-------------
    // //  5  | ~CDIV | Clock Divider Bit. This sets the divide ratio of the MCLK signal to produce the internal ICLK. Setting CDIV = 0 divides the MCLK by 2. If CDIV = 1, the ICLK frequency is equal to the MCLK.
    // //  3  | PD    | Power Down. Setting this bit powers down the AD7760, reducing the power consumption to 6.35 mW.
    // //  2  | LPWR  | Low Power. If this bit is set, the AD7760 is operating in a low power mode. The power consumption is reduced for a 6 dB reduction in noise performance.
    // //  1  | 1     | Write 1 to this bit.
    // //  0  | D1PD  | Differential Amplifier Power Down. Setting this bit powers down the on-chip differential amplifier.

    // // Set lowpower mode for improved noise performance.
    control_reg_2_state = (0x0000 | 1 << 2 | 1 << 1);
    write_control_register(0x0002, control_reg_2_state);

   // Control Register 1:
    // | BIT    | NAME      | DESCRIPTION
    // | 15     | DL_FILT   | Download Filter. Before downloading a user-defined filter, this bit must be set. The filter length bits must also be set at this time. The write operations that follow are interpreted as the user coefficients for the FIR filter until all the coefficients and the checksum have been written.
    // | 14     | RD_OVR    | 2 Read Overrange. If this bit has been set, the next read operation outputs the contents of the overrange threshold register instead of a conversion result.
    // | 13     | RD_GAIN   | 2 Read Gain. If this bit has been set, the next read operation outputs the contents of the digital gain register.
    // | 12     | RD_OFF    | 2 Read Offset. If this bit has been set, the next read operation outputs the contents of the digital offset register.
    // | 11     | RD_STAT   | 2 Read Status. If this bit has been set, the next read operation outputs the contents of the status register.
    // | 10     | 0         | 0 must be written to this bit.
    // | 9      | SYNC      | Synchronize. Setting this bit initiates an internal synchronization routine. Setting this bit simultaneously on multiple devices synchronizes all filters.
    // | 8 to 5 | FLEN[3:0] | Filter Length Bits. These bits must be set when the DL_FILT bit is set before a user-defined filter is downloaded.
    // | 4      | ~BYP_F3   | Bypass Filter 3. If this bit is 0, Filter 3 (programmable FIR) is bypassed.
    // | 3      | ~BYP_F1   | Bypass Filter 1. If this bit is 0, Filter 1 is bypassed. This should only occur when the user requires unfiltered modulator data to be output.
    // | 2 to 0 | DEC[2:0]  | Decimation Rate. These bits set the decimation rate of Filter 2. All 0s implies that the filter is bypassed. A value of 1 corresponds to 2× decimation, a value of 2 corresponds to 4× decimation, and so on, up to the maximum value of 5, corresponding to 32× decimation.
    //
    // Set for 2.5MHZ output data rate (enable Filt 1 & 3, No Decimation).
    // In testing a lower rate may be required, and 0b11 == 3 should be included
    // to enable 8x decimation, lowering data rate to 312.5 kHz.
    control_reg_1_state = (0x0000 | 1<<4 | 1<<3 | DEFAULT_DECIMATION_RATE);
    write_control_register(0x0001, control_reg_1_state);

    // These might be redundant, but this will
    // guarantee a defined state for all pins.
    dataBus.input();
    notRead = HIGH;
    notChipSelect = HIGH;
    notSync = HIGH;
    notReset = HIGH;

    power_down();
}

void ADC_Class::power_up()
{
    write_control_register(0x0002, (control_reg_2_state & ~(1 << 3)));
    // worst case filter latency is about 350 us.
    wait_ms(100);
}

void ADC_Class::power_down()
{
    write_control_register(0x0002, (control_reg_2_state | (1 << 3)));
}

void ADC_Class::start_sampling()
{
    power_up();
    notDataReady.rise(&collect_samples);
    notDataReady.enable_irq();
}

void ADC_Class::stop_sampling()
{
    notDataReady.disable_irq();
    // Save power, and power down when not being used.
    power_down();
}


void ADC_Class::change_decimation_rate(int multiplier)
{
    power_up();
    control_reg_1_state = ((control_reg_1_state & 0xFFF8) | multiplier);
    write_control_register(0x0001, control_reg_1_state);
    power_down();
}

uint16_t ADC_Class::read_status_register(bool print_to_console)
{
    uint16_t status_reg = 0;

    power_up();
    status_reg = read_adc_reg(11);
    power_down();
    if (print_to_console)
    {
        // Pretty print the received status register to stdout.
        printf("Status Register\n");
        printf("| Part No. | Die No. | Low Pwr | Overrange | Download O.K. | User Filt O.K. | User Filt EN | Byp Filt 3 | Byp Filt 1 | Dec Rate |\n");
        printf("|     %d    |    %d    |    %d    |     %d     |       %d       |       %d        |      %d       |      %d     |     %d      |    %2d    |\n",
                (status_reg & 0xC000) >> 14, //Part No.
                (status_reg & 0x3800) >> 11, // Die No.
                (status_reg & 0x0200) >> 9,  // Low Pwr
                (status_reg & 0x0100) >> 8,  // Overrange
                (status_reg & 0x0080) >> 7,  // Download OK
                (status_reg & 0x0040) >> 6,  // User Filt OK
                (status_reg & 0x0020) >> 5,  // User Filt EN
               !(status_reg & 0x0010) >> 4,  // Byp Filt 3
               !(status_reg & 0x0008) >> 3,  // Byp Filt 1
                1 << (status_reg & 0x0007)); // Dec 2:0, Use left shift to do exponentiation.
    }

    return status_reg;
}

uint16_t ADC_Class::read_offset_register(bool print_to_console)
{
    uint16_t status_reg = 0;

    power_up();
    status_reg = read_adc_reg(12);
    power_down();
    if (print_to_console)
    {
        printf("%04x\n", status_reg);
    }
    return status_reg;
}

uint16_t ADC_Class::read_gain_register(bool print_to_console)
{
    uint16_t status_reg = 0;

    power_up();
    status_reg = read_adc_reg(13);
    power_down();
    if (print_to_console)
    {
        printf("%04x\n", status_reg);
    }
    return status_reg;
}

uint16_t ADC_Class::read_overrange_register(bool print_to_console)
{
    uint16_t status_reg = 0;

    power_up();
    status_reg = read_adc_reg(14);
    power_down();
    if (print_to_console)
    {
        printf("%04x\n", status_reg);
    }
    return status_reg;
}

void ADC_Class::collect_samples()
{
    // called on interrupt from notDataReady pin
    static int32_t sample_index = 0;

    if (sample_index < NUMBER_OF_SAMPLES)
    {
        // this should all happen in under 250 ns for maximum data rate.
        sample_array[sample_index] = ADC_Class::read_data_word();
        sample_index++;
    }
    else
    {
        stop_sampling();
        sample_index = 0;
        data_ready = 1;
    }
}

uint16_t ADC_Class::read_adc_reg(uint8_t offset)
{
    uint16_t adc_reg;

    // Set signals up for writing to adc.
    notRead = HIGH;
    notChipSelect = HIGH;
    dataBus.output();

    // write to Control Register 1.

    // | BIT    | NAME      | DESCRIPTION
    // | 15     | DL_FILT   | Download Filter. Before downloading a user-defined filter, this bit must be set. The filter length bits must also be set at this time. The write operations that follow are interpreted as the user coefficients for the FIR filter until all the coefficients and the checksum have been written.
    // | 14     | RD_OVR    | 2 Read Overrange. If this bit has been set, the next read operation outputs the contents of the overrange threshold register instead of a conversion result.
    // | 13     | RD_GAIN   | 2 Read Gain. If this bit has been set, the next read operation outputs the contents of the digital gain register.
    // | 12     | RD_OFF    | 2 Read Offset. If this bit has been set, the next read operation outputs the contents of the digital offset register.
    // | 11     | RD_STAT   | 2 Read Status. If this bit has been set, the next read operation outputs the contents of the status register.
    // | 10     | 0         | 0 must be written to this bit.
    // | 9      | SYNC      | Synchronize. Setting this bit initiates an internal synchronization routine. Setting this bit simultaneously on multiple devices synchronizes all filters.
    // | 8 to 5 | FLEN[3:0] | Filter Length Bits. These bits must be set when the DL_FILT bit is set before a user-defined filter is downloaded.
    // | 4      | ~BYP_F3   | Bypass Filter 3. If this bit is 0, Filter 3 (programmable FIR) is bypassed.
    // | 3      | ~BYP_F1   | Bypass Filter 1. If this bit is 0, Filter 1 is bypassed. This should only occur when the user requires unfiltered modulator data to be output.
    // | 2 to 0 | DEC[2:0]  | Decimation Rate. These bits set the decimation rate of Filter 2. All 0s implies that the filter is bypassed. A value of 1 corresponds to 2× decimation, a value of 2 corresponds to 4× decimation, and so on, up to the maximum value of 5, corresponding to 32× decimation.
    //

    write_control_register(0x0001, (control_reg_1_state | (1 << offset)));

    notChipSelect = LOW;
    wait_4_MCLK_cycles();
    notChipSelect = HIGH;

    // Reset dataBus to read data, this takes long enough
    // that a explicit pause isn't necessary.
    dataBus.input();
    // The dataBus should now have the status on it.
    notRead = LOW;
    notChipSelect = LOW;
    wait_4_MCLK_cycles();
    // Grab the raw input
    adc_reg = dataBus.read();
    notChipSelect = HIGH;
    notRead = HIGH;

    // put the bit from the raw input into the correct order.
    adc_reg = dataBus.detangle(adc_reg);

    return adc_reg;
}

uint32_t ADC_Class::read_data_word()
{
    static uint16_t MSB_16;
    static uint16_t LSB_16;

    notRead = LOW;
    notChipSelect = LOW;
    wait_4_MCLK_cycles();
    MSB_16 = dataBus.read();
    notChipSelect = HIGH;
    notRead = HIGH;

    wait_4_MCLK_cycles();

    notRead = LOW;
    notChipSelect = LOW;
    wait_4_MCLK_cycles();
    LSB_16 = dataBus.read();
    notChipSelect = HIGH;
    notRead = HIGH;

    // concatenate and return the 32 bit data word.
    return ((MSB_16 << 16) | LSB_16);
}

void ADC_Class::write_control_register(uint16_t control_register, uint16_t value)
{
    dataBus.output();

    dataBus.write(control_register);
    notChipSelect = LOW;
    wait_4_MCLK_cycles();
    notChipSelect = HIGH;
    wait_4_MCLK_cycles();

    dataBus.write(value);
    notChipSelect = LOW;
    wait_4_MCLK_cycles();
    notChipSelect = HIGH;
    wait_4_MCLK_cycles();

    // Pull the lines down before switching to input
    dataBus.write (0x0000);

    dataBus.input();
}

void ADC_Class::wait_4_MCLK_cycles()
{
    // Calling this function results in a delay of about 100 ns
    // or around 4 cycles of the ADC MCLK at 40 MHz.
    // Without this a high-low-high cycle take about 30 ns ~= 1 MCLK cycle.
    busy_wait_variable = 0;
    busy_wait_variable ++;
}
```

+++++

#### pins.h

```c++
#ifndef PINDEFS_H
#define PINDEFS_H

#include <stdint.h>
#include "mbed.h"

//                  LSB0    1     2     3      4      5     6     7      8     9    10    11    12     13    14    MSB
// #define DATAPINS PC_8, PC_6, PC_5, PA_12, PA_11, PA_9, PA_8, PA_10, PC_1, PA_4, PA_1, PA_0, PA_6, PA_7, PC_7, PA_15
#define PORT_A_MASK (                 1<<12 |1<<11 |1<<9 |1<<8 |1<<10       |1<<4 |1<<1 |1<<0 |1<<6 |1<<7        |1<<15)
#define PORT_C_MASK (1<<8|1<<6 |1<<5                                  |1<<1                               |1<<7        )

#define HIGH 1
#define LOW 0

class DataBusClass
{
private:
    uint16_t port_a;
    uint16_t port_c;
public:
    DataBusClass();
    void input();
    void output();
    void mode(PinMode mode);
    uint16_t read();
    uint16_t detangle(uint16_t raw_input);
    void write(uint16_t word);
};

extern DataBusClass dataBus;

extern InterruptIn notDataReady;
extern DigitalOut notSync;
extern DigitalOut notRead;
extern DigitalOut notChipSelect;
extern DigitalOut notReset;

// extern DigitalOut led;

#endif

```
#### pins.cpp

```c++

#include "pins.h"

DataBusClass dataBus;

InterruptIn notDataReady(PC_12);
DigitalOut notSync(PC_10);
DigitalOut notRead(PA_13);
DigitalOut notChipSelect(PA_14);
DigitalOut notReset(PC_11);

// DigitalOut led(LED1);

PortInOut dataBusA(PortA, PORT_A_MASK);
PortInOut dataBusC(PortC, PORT_C_MASK);

// DigitalOut LED()

DataBusClass::DataBusClass()
{
    port_a = 0;
    port_c = 0;
}

void DataBusClass::input()
{
    dataBusA.input();
    dataBusC.input();
}

void DataBusClass::output()
{
    dataBusA.output();
    dataBusC.output();
}

void DataBusClass::mode(PinMode mode)
{
    dataBusA.mode(mode);
    dataBusC.mode(mode);
}

uint16_t DataBusClass::read()
{
    // efficiently pack the bits into a 16 bit container.
    // bit order is even more messed up than before of course,
    // but that detanglement can be handled on the pc side.
    uint16_t received;

    // leave port a value where they are.
    received = dataBusA.read();

    // Fill in space between port a values (pa02, pa03, pa 13, and pa14 are not used) with the port c values.
    port_c = dataBusC.read();
    received |= (port_c & (1 << 1)) << 1;      // pc01 to bit 2
    received |= (port_c & (1 << 8)) >> 5;      // pc08 to bit 3
    received |= (port_c & (1 << 5));           // pc05 to bit 5
    received |= (port_c & ((1 << 6) | (1 << 7))) << 7;      // pc06 to bit 13 and  pc07 to bit 14
    return received;
}

uint16_t DataBusClass::detangle(uint16_t raw_input)
{
    uint16_t decoded_word = 0x0000;

    decoded_word |= (raw_input & (1 << 0))  << (-(0 - 11));   // pa00 to bit 11
    decoded_word |= (raw_input & (1 << 1))  << (-(1 - 10));   // pa01 to bit 10

    decoded_word |= (raw_input & (1 << 2))  << (-(2 - 8));    // pc01 in pos 2 to bit 8
    decoded_word |= (raw_input & (1 << 3))  >> (3 - 0);       // pc08 in pos 3 to bit 0

    decoded_word |= (raw_input & (1 << 4))  << (-(4 - 9));    // pa04 to bit 9

    decoded_word |= (raw_input & (1 << 5))  >> (5 - 2);        // pc05 in pos 5 to bit 2

    decoded_word |= (raw_input & (1 << 6))  << (-(6 - 12));   // pa06 to bit 12
    decoded_word |= (raw_input & (1 << 7))  << (-(7 - 13));   // pa07 to bit 13
    decoded_word |= (raw_input & (1 << 8))  >> (8 - 6);       // pa08 to bit 6
    decoded_word |= (raw_input & (1 << 9))  >> (9 - 5);       // pa09 to bit 5
    decoded_word |= (raw_input & (1 << 10)) >> (10 - 7);      // pa10 to bit 7
    decoded_word |= (raw_input & (1 << 11)) >> (11 - 4);      // pa11 to bit 4
    decoded_word |= (raw_input & (1 << 12)) >> (12 - 3);      // pa12 to bit 3

    decoded_word |= (raw_input & (1 << 13)) >> (13 - 12);     // pc06 in pos 13  to bit 1
    decoded_word |= (raw_input & (1 << 14)) >> (14 - 14); // pc07 in pos 14 to bit 14

    decoded_word |= (raw_input & (1 << 15)) >> (15 - 15);     // pa15 to bit 15

    return decoded_word;
}

void DataBusClass::write(uint16_t word)
{
    port_a = 0x0000;
    port_c = 0x0000;

    // port,   bit select, shift by (pin num - bit pos)
    port_c |= (word & (1 << 0)) << (8 - 0);       // pc08
    port_c |= (word & (1 << 1)) << (6 - 1);       // pc06
    port_c |= (word & (1 << 2)) << (5 - 2);       // pc05

    port_a |= (word & (1 << 3)) << (12 - 3);      // pa12
    port_a |= (word & (1 << 4)) << (11 - 4);      // pa11
    port_a |= (word & (1 << 5)) << (9 - 5);       // pa09
    port_a |= (word & (1 << 6)) << (8 - 6);       // pa08
    port_a |= (word & (1 << 7)) << (10 - 7);      // pa10

    port_c |= (word & (1 << 8)) >> (-(1 - 8));    // pc01

    port_a |= (word & (1 << 9)) >> (-(4 - 9));    // pa04
    port_a |= (word & (1 << 10)) >> (-(1 - 10));  // pa01
    port_a |= (word & (1 << 11)) >> (-(0 - 11));  // pa00
    port_a |= (word & (1 << 12)) >> (-(6 - 12));  // pa06
    port_a |= (word & (1 << 13)) >> (-(7 - 13));  // pa07

    port_c |= (word & (1 << 14)) >> (-(7 - 14));  // pc07

    port_a |= (word & (1 << 15)) >> (-(15 - 15)); // pa15

    dataBusA.write(port_a);
    dataBusC.write(port_c);
}
```

### Host application.

#### pc_data.py
```py
import logging
import serial
import io
import dash
import dash_core_components as dcc
import dash_html_components as html
import dash.dependencies as dd
import dash.exceptions as de
from adc_comms import SerialComms

# deques are used for thread safe sharing of data
from collections import deque
import numpy as np
from time import sleep

# Initialization
adc = SerialComms()

# Initialize various arrays, global arrays are used for preserving data between
# function invocations.
magnitude = [0]
sample_index = [0]
freq_mag = [1e-24]
freq_mag_history = deque(maxlen=1)
freq_axis = [0]
rms_mag = 0
# Define the refresh interval, determined empirically. it would be better if
# this could retrigger on the acquisition loop callback completion, but I can
# only get this to function off a timer so here we are.
update_period_ms = {'1024': 900,
                    '4096': 2000,
                    '8192': 2000,
                    '16384': 2000 }

# This array constructs the window functions used.
# It interacts with the window-functions id in the dash app.
window_map = {}

# Create the dash app object
app = dash.Dash()

# This is the GUI layout.
app.layout = html.Div(id='Body',
    children=
    [
        # Page/Project title
        html.H1(id='title',
            children="Iridium ADC"
        ),

        # Insert a blank line
        html.P(''),

        # Controls to change sampling properties
        html.Div(id='sampling-properties-container',
            style={'width': '40%'},
            children=
            [
                html.P(''),
                html.Label('Sample Rate Selection:'),
                dcc.Dropdown(id='sample-rate',
                    options=
                    [
                        # 'label' is the sample rate, 'value' corresponds to the
                        # corresponding decimation rate register setting.

                        # higher rates are not supported yet
                        # {'label':'2.5 MSPS', 'value': '2500000'},
                        # {'label':'1.25 MSPS', 'value': '1250000'},
                        # {'label':'625 kSPS', 'value': '625000'},
                        {'label':'312.5 kSPS', 'value': '312500'},
                        {'label':'156.25 kSPS', 'value': '156250'},
                        {'label':'78.125 kSPS', 'value': '78125'},
                    ],
                    value='78125',
                ),

                html.P(''),
                html.Label('Number of samples:'),
                dcc.Dropdown(id='number-of-samples',
                    options=
                    [
                        {'label': '1024', 'value': '1024'},
                        {'label': '4096', 'value': '4096'},
                        {'label': '8192', 'value': '8192'},
                        {'label': '16384', 'value': '16384'},
                    ],
                    value='16384',
                ),

                html.P(''),
                html.Label('Window:'),
                dcc.Dropdown(id='window-functions',
                    options=
                    [
                        {'label':'Rect', 'value':'rect'},
                        {'label':'Blackman', 'value':'blackman'},
                        {'label':'Kaiser 5', 'value':'kaiser5'},
                        {'label':'Kaiser 7', 'value':'kaiser7'},
                    ],
                    value='kaiser5',
                ),

                html.P(''),
                html.Label('Number of averages: '),
                dcc.Input(id='number-of-averages',
                    placeholder='Enter a number',
                    type='number',
                    value=10,
                    pattern='[0-9]+',
                    min=2,
                    max=1000
                ),

                html.P(''),

                html.Div(id='control-buttons',
                    style={'column':3},
                    children=
                    [
                        # Button to turn graph updating on or off.
                        html.Button(id='graph-update-button',
                            n_clicks=0,
                            accessKey='p'
                        ),


                        # Button to turn frequency domain magnitude averaging on or off.
                        html.Button(id='freq-average-button',
                            n_clicks=0,
                        ),

                        # Button to toggle time domain data in raw form or windowed form.
                        html.Button(id='show-windowed-button',
                            n_clicks=0,
                        ),
                    ]),
            ],
        ),

        html.Div(id='graph-div',
            children=
            [
                # The time domain graph object.
                dcc.Graph(id='time-domain-graph'),

                # The frequency domain graph object.
                dcc.Graph(id='freq-domain-graph'),
            ]
        ),

        html.Div(id='statistics-display', children='Can you see me?'),

        # Interval object triggers the data acquisition
        dcc.Interval(id='update-timer',
            interval=4000,
            n_intervals=0
        ),

        # Accumulated status indicates if the sample contained overrange events.
        # This is returned from the acquisition loop and triggers the update of
        # the graph objects.
        html.Div(id='accumulated-status',
            style={'display': 'none'},
            children=''
        ),

        html.Div(id='placeholder',
            style={'display': 'none'}
        ),
    ])


@app.callback(
    dd.Output('placeholder', 'children'),
    [dd.Input('sample-rate', 'value'),
     dd.Input('number-of-samples', 'value'),
     dd.Input('number-of-averages', 'value')])
def update_properties(sample_rate, number_of_samples, number_of_averages):
    '''Send a control signal to the MCU to change the sample rate or number
    of samples'''
    global window_map, freq_axis, freq_mag_history

    if int(sample_rate) != adc.sample_rate or int(number_of_samples) != adc.number_of_samples:
        # Requires board reset so only do if necessary.
        status_reg_f = '\n'.join(adc.modify_sample_properties(sample_rate, number_of_samples))
        # rebuild the window map
        window_map = {'rect': [1] * adc.number_of_samples,
                      'blackman': np.blackman(adc.number_of_samples),
                      'kaiser5': np.kaiser(adc.number_of_samples, 5 * np.pi),
                      'kaiser7': np.kaiser(adc.number_of_samples, 7 * np.pi),}
        # Get, format, and log the status register.
        logging.info(status_reg_f)

    # set the size of the history deque, and in the process clear it..
    freq_mag_history = deque(maxlen=number_of_averages)

    # Create a new frequency axis.
    freq_axis = np.fft.rfftfreq(n=adc.number_of_samples, d=1/adc.sample_rate)

    return ''


@app.callback(
    dd.Output('update-timer', 'interval'),
    [dd.Input('graph-update-button', 'n_clicks'),
     dd.Input('number-of-samples', 'value')])
def toggle_graph_update(n_clicks, number_of_samples):
    '''Prevent the graphs from updating by setting a really long interval time.'''
    if (n_clicks % 2 == 0):
        return update_period_ms[number_of_samples]
    else:
        # Setting disable is not working so instead just set a ridiculously long
        # interval. In this case about 317 years.
        return 10e12

@app.callback(
    dd.Output('graph-update-button', 'children'),
    [dd.Input('graph-update-button', 'n_clicks')])
def update_graph_button(n_clicks):
    '''Update the text on the graph update button'''
    if (n_clicks % 2 == 0):
        return 'Graph updates are ON'
    else:
        return 'Graph updates are OFF'


@app.callback(
    dd.Output('freq-average-button', 'children'),
    [dd.Input('freq-average-button', 'n_clicks')])
def freq_average_button(n_clicks):
    '''Update text on button, the actual effect of the button is handled in
    the frequency domain graph callback.'''
    if (n_clicks % 2 == 0):
        return 'Freq domain averaging OFF'
    else:
        return 'Freq domain averaging ON'


@app.callback(
    dd.Output('show-windowed-button', 'children'),
    [dd.Input('show-windowed-button', 'n_clicks')])
def show_windowed_button(n_clicks):
    '''Update text on button, the actual effect is handled in the time domain
    update callback'''
    if (n_clicks % 2 == 0):
        return 'Time domain window OFF'
    else:
        return 'Time domain window ON'


@app.callback(
    dd.Output('accumulated-status', 'children'),
    [dd.Input('update-timer', 'n_intervals')])
def acquire_data(n_intervals):
    '''This function triggers the adc to take a measurement and then transfer the
    data back to us. The accumulated status is updated, triggering the update
    of both graphs.'''
    if adc.stop_loops or adc.loop_running or n_intervals == 0:
        # Prevent starting a serial connection when something is already active,
        # including another threaded instance of this function.
        raise de.PreventUpdate
    adc.loop_running = True
    logging.info("Starting acq loop")
    adc.acquisition_loop()
    adc.decode_loop()
    adc.loop_running = False
    return (f'accumulated status: {adc.accumulated_status}')


@app.callback(
    dd.Output('time-domain-graph', 'figure'),
    [dd.Input('accumulated-status', 'children'),
     dd.Input('show-windowed-button', 'n_clicks'),
     dd.Input('window-functions', 'value')],
    [dd.State('time-domain-graph', 'relayoutData')])
def time_domain_update(status, show_windowed_clicks, window, relayoutData):
    '''Process the acquired data and display in time domain.'''
    global sample_index, rms_mag
    try:
        magnitude = adc.decoded_data_queue[0]
        rms_mag = np.sqrt(np.mean((magnitude - np.mean(magnitude))**2))
        magnitude -= np.mean(magnitude)
        # print('magnitude: {}'.format(magnitude))
        sample_index = 1 / adc.sample_rate * np.linspace(0, adc.number_of_samples,
                num=adc.number_of_samples,
                endpoint=False)
    except IndexError:
        # no data in queue, exit the function without doing anythin
        return

    show_windowed = (show_windowed_clicks % 2 != 0)

    if show_windowed:
        magnitude = magnitude * window_map[window]

    # This is how to access the new axis limits if the user changes them. They
    # start as None so some logic will be required. Will also need to figure out
    # how resetting axis limits works with this.
    # print(relayoutData)
    # print(relayoutData['xaxis.range[0]'])

    return {'data': [{'x': sample_index, 'y': magnitude,
                      # 'type': 'line',
                      'name': 'time domain',
                      # 'mode': 'lines+markers',
                    }],
            'layout': {'title': 'Magnitude vs. sample',
                       'xaxis': {'title': 'Time [secs]',
                                 'range': [0, adc.number_of_samples/adc.sample_rate]
                                },
                       'yaxis': {'title': 'Magnitude [V]',
                                 # 'range': [-2, 2]
                                }
                      }
           }

@app.callback(dd.Output('freq-domain-graph', 'figure'),
             [dd.Input('accumulated-status', 'children'),
              dd.Input('window-functions', 'value')],
             [dd.State('freq-average-button','n_clicks'),
              dd.State('sample-rate', 'value'),
              dd.State('number-of-samples', 'value'),
              dd.State('number-of-averages', 'value')])
def freq_domain_update(status,
                       window,
                       average_clicks,
                       sample_rate,
                       number_of_samples,
                       number_of_averages):
    '''Apply a window and take the fft of the input signal to display the
    information in the frequency domain'''
    global freq_axis, freq_mag, freq_mag_history

    try:
        magnitude = adc.decoded_data_queue[0]
        freq_mag = (magnitude - np.mean(magnitude)) * window_map[window]
    except IndexError:
        # Indicates no data in the queue, exit function without doing something.
        return
    except ValueError:
        # The magnitude array is not the same length as the window. This is a
        # problem.
        logging.error(f'Input buffer size {len(magnitude)} expected {adc.number_of_samples}')
        raise de.PreventUpdate

    # Compute the frequency magnitude in dBRMS
    freq_mag = np.abs(np.fft.rfft(a=freq_mag, n=adc.number_of_samples)
        * np.sqrt(2) / adc.number_of_samples
        / sum(window_map[window]) * len(window_map[window]))
    # Store every value and calculate the average.
    freq_mag_history.append(freq_mag)
    freq_avg_mag = np.mean(freq_mag_history, axis=0)

    # convert to decibels and decide if we are using the averaged values or not:
    average_on = (average_clicks % 2 != 0)
    if average_on:
        freq_mag_dB = 20 * np.log10(freq_avg_mag)
    else:
        freq_mag_dB = 20 * np.log10(freq_mag)

    return {'data': [{'x': freq_axis, 'y': freq_mag_dB,
                      # 'type': 'line',
                      'name': 'freq domain',
                      'mode': 'lines'}],
            'layout': {'title': 'FFT of input',
                       'xaxis': {'title': 'Frequency [Hz]',
                                 'type': 'log',
                                 # 'range': np.log10([10, adc.sample_rate/2])
                                 'range': 'auto',
                                 },
                       'yaxis': {'title': 'RMS Magnitude [dBV]',
                                 'range': [-150, 30]
                                 }
                      }
           }


@app.callback(
    dd.Output('statistics-display', 'children'),
    [dd.Input('accumulated-status', 'children')])
def statistics_display(fft_plot):
    global rms_mag
    return(f'AC RMS Input: {rms_mag}')

if __name__ == '__main__':
    dash_log = logging.getLogger('werkzeug')
    dash_log.setLevel(logging.ERROR)
    app.run_server(debug=False)
```
#### adc_comms.py

```py
import logging
import serial
import io
from time import sleep

# deques are used for sharing of data
from collections import deque

# Use logger for, um, logging...
logging.basicConfig(level=logging.DEBUG)

# Couple of helpful macros used in conversion of strings to ints.
HEX = 16
BIN = 2

# SCALE_FACTOR is multiplied by the normalized signal magnitude, where the full
# scale range is -1 to 1
SCALE_FACTOR = 8.44190

data_buffer = []

class SerialComms():
    ser = serial.Serial()
    ser.baudrate = 1500000
    ser.bytesize = serial.EIGHTBITS
    ser.parity = serial.PARITY_NONE
    ser.stopbits = serial.STOPBITS_ONE
    ser.timeout = 0.5
    ser.port = 'COM5'

    number_of_samples = 0
    sample_rate = 0

    loop_running = False
    stop_loops = False
    accumulated_status = '0b00000000'

    def __init__(self):
        self.input_data_queue = deque(maxlen=1)
        self.decoded_data_queue = deque(maxlen=1)
        self.ser.open()
        self.sio = io.TextIOWrapper(io.BufferedRWPair(self.ser, self.ser), encoding='utf-8')
        self.reset()

    def status(self):
        '''Get the status register
        Calling this will also pick out the decimation rate and update the
        sample rate.'''

        # Consume anything in the input buffer.
        self.sio.read()
        # Write control signal
        self.write('R')
        logging.debug('Message sent: read status register')

        status_table = [self.readline() for kk in range(4)]
        return status_table

    def start_sampling(self):
        '''Get the adc to start sampling.'''
        self.write('S')
        logging.debug('Message sent: Start sampling')

    def write(self, signal):
        '''Send a control signal'''
        self.sio.write(signal)
        self.sio.flush()
        sleep(0.1)

    def readline(self):
        '''Read a line from the buffer.'''
        return self.sio.readline().strip()

    def reset(self):
        self.ser.send_break(0.1)
        logging.debug('Message sent: Break command ')
        self.ser.reset_input_buffer()
        sleep(0.1)

    def setup(self):
        self.write('P')
        logging.debug('Message sent: Setup Signal')


    def acquisition_loop(self):
        self.start_sampling()

        data_buffer = []
        '''Loop that waits for start, collects all the samples and stores result.'''
        for nn in range(int(self.number_of_samples)*6):
            # find the start of the data
            if self.stop_loops:
                logging.info(f'Stop loop encountered')
                return
            cur_line = self.readline()
            if 'start' in cur_line:
                logging.info(f'start line found: "{cur_line}"')
                cur_line = self.readline()
                logging.debug(f'first received message: "{cur_line}"')
                for kk in range(int(self.number_of_samples)*2):
                    if ('stop' in cur_line):
                        break
                    if self.stop_loops:
                        logging.info(f'Stop loop encountered')
                        return
                    try:
                        data_buffer.append(int(cur_line, HEX))
                    except ValueError:
                        logging.error(f'Non Hex message received: "{cur_line}"')
                        # signal not received correctly. retransmit the
                        # same signal
                    # logging.info(f'Current size of data buffer {len(data_buffer)}')
                    #  Write the signal
                    cur_line = self.readline()
                    # logging.debug(f'message received: "{cur_line}"')

                logging.info(f'End line found: "{cur_line}"')

                self.input_data_queue.append(data_buffer)
                return
        logging.error('"start" was never found.')
        return

    def decode_loop(self):
        untangled_buffer = []
        try:
            tangled_buffer = self.input_data_queue.pop()
            self.accumulated_status = '0b0'

            for tangled_sample in tangled_buffer:
                # Convert to 32 bit binary LSB at index 0 for easiest match
                # to the tangled bit order.
                T = format(tangled_sample, '032b')

                #         Bit: |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
                # Pos in Word: |15|14| 7| 6| 0| 1| 4| 2|10| 8| 9|11|12| 5|13| 3|
                #  Pos in Str: | 0| 1| 8| 9|15|14|11|13| 5| 7| 6| 4| 3|10| 2|12|

                # Reorder Bits:         7       6       5       4       3        2       1      0
                untangled_string = (  T[0]  + T[1]  + T[8]  + T[9]  + T[15] + T[14] + T[11] + T[13]
                                    + T[5]  + T[7]  + T[6]  + T[4]  + T[3]  + T[10] + T[2]  + T[12]
                                    + T[16] + T[17] + T[24] + T[25] + T[31] + T[30] + T[27] + T[29]
                                    + T[21] + T[23] + T[22] + T[20] + T[19] + T[26] + T[18] + T[28] )
                if untangled_string[-6:]  != '010000':
                    pass
                    logging.debug(f'Impossible status, Untangled String: {untangled_string}')
                # logging.debug(f'Untangled String: {untangled_string}')
                self.accumulated_status = format((int(self.accumulated_status, BIN)
                                                      | int(untangled_string[-8:], BIN)), '#010b')
                if untangled_string[0] == '1':
                    # indicates negative in twos complement
                    untangled_buffer.append((int(untangled_string[0:24], BIN)
                                             - (1<<24)) / (2**23-1) * SCALE_FACTOR)
                else:
                    untangled_buffer.append((int(untangled_string[1:24], BIN))
                                            / (2**23 - 1) * SCALE_FACTOR)

            self.decoded_data_queue.append(untangled_buffer)

        except IndexError:
            # indicates input_data_queue is empty, can happen if stop_loops was
            # set true.
            pass

    def modify_sample_properties(self, sample_rate, number_of_samples):

        self.stop_loops = True

        sample_rate_to_decimation_dict = {'2500000': '0',
                                          '1250000': '1',
                                          '625000': '2',
                                          '312500': '3',
                                          '156250': '4',
                                          '78125': '5',
                                          '': '0'}

        number_of_samples_to_MCU_code = {'1024': '0',
                                         '4096': '1',
                                         '8192': '2',
                                         '16384': '3'}

        decimation_rate = sample_rate_to_decimation_dict[sample_rate]
        sample_code = number_of_samples_to_MCU_code[number_of_samples]

        self.reset()
        self.setup()

        # write the decimation rate
        self.write('D')
        self.write(decimation_rate)
        # write the sample_rate
        self.write('L')
        self.write(sample_code)

        logging.debug(f'Message sent: Decimation "D{decimation_rate}, Sampling "L{sample_code}')

        # Update the internal parameters.
        self.sample_rate = int(sample_rate)
        self.number_of_samples = int(number_of_samples)

        status_reg = self.status()

        self.stop_loops = False
        logging.debug("stop loop set to false")

        return status_reg

if __name__ == '__main__':
    '''if this file is run on its own it will perform some tests including
    timing how long a transfer takes '''

    import timeit
    TEST_ITERATIONS = 10

    ser_test = SerialComms()

    ser_test.input_data_queue = deque(maxlen=TEST_ITERATIONS)
    ser_test.decoded_data_queue = deque(maxlen=TEST_ITERATIONS)

    ser_test.modify_sample_properties('156250', '1024')

    print('\n'.join(ser_test.status()))

    ser_test.write('v')
    logging.info(f'Overrange: 0x{ser_test.readline().upper()} default is 0xCCCC')
    ser_test.write('f')
    logging.info(f'Offset: 0x{ser_test.readline().upper()} default is 0x0000')
    ser_test.write('g')
    logging.info(f'Gain: 0x{ser_test.readline().upper()} default is 0xA000')


    logging.info('Acquisition Loop time: {}'.format(
        timeit.timeit(ser_test.acquisition_loop, number=TEST_ITERATIONS) / TEST_ITERATIONS))
    logging.info('Decode Loop time: {}'.format(
        timeit.timeit(ser_test.decode_loop, number=TEST_ITERATIONS) / TEST_ITERATIONS))
    logging.info(f'length of decoded buffers:\n\t{[len(x) for x in list(ser_test.decoded_data_queue)]}')
```

<!-- Markdeep footer -->
    <script src="C:/Users/boxca/Google Drive/_misc/markdeep/markdeep.js"></script>
    <script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script>
